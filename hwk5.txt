hwk5 by Lucas Sacherer and Grace Seiche
Question 1:
a) The first and biggest advantage that Graham thought lisp gave his company was the power of lisp. A powerful language allows you to do a lot with a small time investment, so his company was able to release features much faster than any of his competitors. They got to the point where it would only take a few days after a competitor released a new feature for them to mimic it. This allowed them to stay on top of the industry and consistently be the best program. The next big advantage was the fact that lisp had macros. Graham said that macros is the feature that he saw as missing from all other popular programming languages, especially since 20-25% of his code was macros. This meant that at least 20% of his code was stuff that was hard to do in any other language. This again reduced development time compared to his competitors. The final advantage was that lisp was a very high level language, meaning that Graham would only need a small development team compared to his competitors. This lead to much lower development costs which meant they could offer their service at a lower cost, undercutting the competition. 

b) The first observation that I found significant was the idea that languages have a certain power associated to them. He claimed that at the time lisp was the most powerful language available. This is a very significant because it goes against the way many people think about languages. Most people will talk about the compromise of choosing any language and that no language is inherently better than another, yet here Graham states that some languages are simply more powerful than others. This changes the approach to choosing a language for a project to simply picking the most powerful language possible, which is why he picked lisp.
The second observation I found significant was the entire idea that languages are entire way of thinking instead of just something you write code in. This is a very important statement because it explains the industry’s refusal to move on from “mid-tier” languages like C to more powerful/ higher-level languages. This fact is exactly how Graham’s company worked and was able to take on everybody who tried to compete. Not thinking in a single language or knowing many languages to think in is a clear way to get an advantage over other programmers/ competitors.
Question 2:
1. Did the creators of the language make it for themselves or for others?
2. Did the language have to advertise to become popular or did it become a standard on its own merits?
3. Does anybody actually love using the language?
Question 3:
Cooking recipes are examples of languages. A language is a way to represent something and in the case of cooking, recipes are the language that represent a meal. The recipes are used by a community of chefs to perform the shared activity of cooking and creating a meal.  The programs in the language would be each individual recipe because while the language of a general recipe gives the tools for creating a food, an actual recipe will actually create a food. The data, in this case, would be the amounts, ingredients, and step by step directions. They are all taken and use by operations such as the list of ingredients, the list of directions, and the title of the recipe. The control is like the rules that govern the recipe (i.e. first there is the title operation, then the list of ingredients operation, then the list of directions operation). The language’s syntax is that there is a title of a recipe followed by a list of ingredients, where each ingredient has a food product and an amount. After the list of ingredients, there is a list of directions that include ingredients and instructions on what to do with them. The interpreter of the recipe would be a chef, who performs the recipe and produces the “data value” of the meal outlined in the recipe.
Theoretically, recipes could be amenable to computer processing. However, there would be many more details to work out. A standard laptop cannot read a recipe and produce a meal. It does not even have access to food. Therefore, in order to computer process a recipe, a special computer and machine combination would have to be created. This would have to give a machine access to a library (pantry) of foods that it would then access according to the given recipe. This already exists in large scale factory settings where machines are given instructions and are pre-set to make foods. 
